Arros (Arrow Streaming) 는 최근 빅데이터 분야에서 널리 사용되고 있는 [Arrow](https://arrow.apache.org/) 를 기반으로 하는 Rust 기반의 스트리밍 엔진이다. 이는 기존의 Java/Scala 기반의 [Spark](https://spark.apache.org/) 와 [Flink](https://flink.apache.org/) 를 대체하는 기술로, 적은 자원으로 빅데이터에 준하는 데이터를 실시간으로 처리하기 위해 개발되었다. 오늘은 우리가 Arros 를 왜 개발하였는지, 그리고 어떻게 사용하는지에 대해 소개하도록 하겠다.

## 왜 개발하였나?

우리는 제조 현장의 생산 시설이나 자동차, 로봇 등으로부터 수집되는 데이터를 실시간으로 빠르게 처리하는 것을 목표로 하고 있기 때문에 기존의 빅데이터를 수집/처리하는 분야와는 많은 부분에서 차이가 있다. 이러한 환경에서는 클라우드나 IDC 로 데이터를 보내서 처리한 결과를 받는 것은 현실적으로 불가능하기 때문에 주로 현장이나 수집 장치 가까이 설치된 엣지 서버에서 실시간으로 데이터를 처리한다. 그래서 무엇보다 적은 자원으로 데이터를 빠르게 처리하는 것이 중요하다고 볼 수 있다.

실시간으로 빅데이터를 처리할 때 주로 사용되는 Spark 와 Flink 가 가지는 문제점에 대해 조금 더 살펴보도록 하자.

### 설치/유지보수

Spark 와 Flink 는 대규모 클러스터 환경에서 빅데이터를 실시간 혹은 배치로 처리하기 위해 개발되었기 때문에 설치와 유지보수에 높은 전문 지식과 노력이 필요하다. 그래서 엣지 서버에 설치해서 사용하기에는 적합하지 않다.

### 메모리 관리

Java 에서 메모리 관리를 도와주는 GC (Garbage Collection) 은 다양한 문제를 유발한다. GC 가 동작할 때마다 시스템 자원을 낭비하고 예측할 수 없는 지연시간을 발생시키기도 하며, 예상하기 힘든 OOM (Out-Of-Memory) 의 원인이 되기도 한다. 그리고 CXL 과 같은 차세대 메모리를 이용하여 시스템 메모리를 늘려도 Java 에서 마음대로 힙(Heap)의 크기를 늘리기 힘든 문제가 있다. (힙의 크기가 늘어나는 만큼 GC 에 의해 관리되는 영역도 늘어나기 때문이다.)

반면에, Rust 는 GC 없이 메모리 안정성을 보장하기 때문에 필요한 만큼 시스템 메모리를 늘릴 수 있고 스왑 메모리도 효과적으로 사용할 수 있어서, Java 에 비해 훨씬 편리하고 효율적으로 메모리를 관리할 수 있다.
