Arros (Arrow Streaming) 는 SQL 을 이용하여 실시간으로 빅데이터를 처리하는 기능을 제공하는, 최근 빅데이터 분야에서 널리 사용되고 있는 [Arrow](https://arrow.apache.org/) 를 이용하여 Rust 기반으로 개발 중인 스트리밍 엔진이다. 이는 기존의 Java/Scala 기반의 [Spark](https://spark.apache.org/) 와 [Flink](https://flink.apache.org/) 를 대체하는 기술로, 적은 자원으로 빅데이터에 준하는 데이터를 실시간으로 처리하기 위해 개발되었다. 오늘은 우리가 Arros 를 왜 개발하였는지, 그리고 어떻게 개발하였고, 어떻게 사용하는지에 대해 살펴보도록 하겠다.

## 왜 개발하였나?

우리는 제조 현장의 생산 시설이나 자동차, 로봇 등으로부터 수집되는 데이터를 실시간으로 빠르게 처리하는 것을 목표로 하고 있기 때문에 기존의 빅데이터를 수집/처리하는 분야와는 많은 부분에서 차이가 있다. 이러한 환경에서는 클라우드나 IDC 로 데이터를 보내서 처리한 결과를 받는 것은 현실적으로 불가능하기 때문에 주로 현장이나 수집 장치 가까이 설치된 엣지 서버에서 실시간으로 데이터를 처리한다. 그래서 무엇보다 적은 자원으로 데이터를 빠르게 처리하는 것이 중요하다고 볼 수 있다.

우선, 실시간으로 빅데이터를 처리할 때 주로 사용되는 Spark 와 Flink 가 가지는 문제점에 대해 조금 더 살펴보도록 하자.

### 설치/유지보수

Spark 와 Flink 는 대규모 클러스터 환경에서 빅데이터를 실시간 혹은 배치로 처리하기 위해 개발되었기 때문에 설치와 유지보수에 높은 전문 지식과 노력이 필요하다. 이러한 방식은 대규모 클러스터를 운영하는 별도의 팀이 있는 IT 기업에서는 적합하지만, 여러 사이트에서 독립적으로 동작하는 엣지 서버를 효율적으로 운영하기에는 적합하지 않다.

### 데이터 구조

Spark 와 Flink 는 기본적으로 Row 기반으로 동작하기 때문에 Column 단위로 분석하는 요청에서는 효율이 떨어진다. 이러한 문제를 해결하기 위해 데이터 구조를 변경하는 기능이 추가되기도 했지만, 기존의 Row 기반으로 동작하는 많은 기능을 제대로 활용할 수 없는 문제가 있다.

### 메모리 관리

Java 에서 메모리 관리를 도와주는 GC (Garbage Collection) 는 다양한 문제를 유발한다. GC 가 동작할 때마다 시스템 자원을 낭비하고 예측할 수 없는 지연시간을 발생시키기도 하며, 예상하기 힘든 OOM (Out-Of-Memory) 의 원인이 되기도 한다. 그리고 CXL 과 같은 차세대 메모리를 이용하여 시스템 메모리를 늘려도 Java 에서 마음대로 힙(Heap)의 크기를 늘리기 힘든 문제가 있다. (힙의 크기가 늘어나는 만큼 GC 에 의해 관리되는 영역도 늘어나기 때문이다.)

### 어떻게 개발하였나?

우리는 응답성과 효율성을 최대한 확보하기 위해 Rust 기반의 [Datafusion](https://datafusion.apache.org/) 을 이용하여 Arros 를 개발하고 있다. 이러한 방식으로 기존의 문제점들을 어떻게 해결 및 개선하였는지 간단히 살펴보도록 하자.

### 설치/유지보수

Arros 는 한 대의 서버에서도 충분히 큰 데이터를 빠르게 처리할 수 있기 때문에 여러 사이트에서 독립적으로 동작하는 엣지 서버에 적합하다. 그리고 안정성이나 확장성이 필요하다면 여러 대의 서버로 확장하는 것 또한 가능하기 때문에 환경에 따라 유연하게 대처할 수 있다. (서버 한 대에서 사용할 수 있는 코어와 메모리가 늘어날수록 처리할 수 있는 데이터는 지속적으로 커질 것이다.)

### 데이터 구조

Datafusion 은 기본적으로 Column 기반으로 동작하기 때문에 Column 기반으로 저장된 데이터(Parquet)를 Column 단위로 분석하는 환경에서 매우 유리하다. 여기에 Column 기반의 네트워크 프로토콜인 [FlightSQL](https://arrow.apache.org/docs/format/FlightSql.html#) 까지 사용한다면 불필요한 데이터 구조 변경없이 빅데이터를 효율적으로 주고 받을 수 있게 된다.

### 메모리 관리

Rust 는 GC 없이 메모리 안정성을 보장하기 때문에 필요한 만큼 시스템 메모리를 사용할 수 있고, 스왑 메모리도 효과적으로 사용할 수 있어서 Java 에 비해 훨씬 편리하고 안정적으로 메모리를 관리할 수 있다. 또한, Java 는 GC 에 의해 메모리를 지속적으로 정리하지 않으면 예기치 못한 OOM 이 발생하지만, Rust 는 커널이 직접 제공하는 스왑 기능 덕분에 충분한 시스템 메모리와 스왑 메모리만 있다면 OOM 은 발생하지 않는다.

아래는 Arros 를 기반으로 엣지 서버를 구성한 모습이다.

![overview.png](./overview.png)
