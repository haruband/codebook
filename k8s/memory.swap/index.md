쿠버네티스는 기본적으로 메모리 스와핑을 지원하지 않는다. 20년 넘는 시간동안 운영체제 관련 연구/개발을 수행하면서 메모리 스와핑이 만들어내는 다양한 문제들에 대한 연구를 많이 봤었고, 이러한 문제들때문에 메모리 스와핑을 강제로 막는 경우도 많이 봤었기 때문에 딱히 이상하진 않았지만, 다양한 워크로드를 지원하는 범용적인 환경에서 아예 지원하지 않는 것은 조금 이상했었다. 그런데, 최근 [쿠버네티스 1.22에서 메모리 스와핑을 지원한다는 기사](https://kubernetes.io/blog/2021/08/09/run-nodes-with-swap-alpha/)를 보고 호기심이 생겨 관련 내용을 조사해보니 꽤 오래전부터 지원 여부에 대한 많은 논의가 있었고, 지금은 과거와 달리 여러 가지 문제가 많이 개선된 상황이니 사용자가 선택할 수 있게 해줘야 한다는 분위기가 된 것 같다. 관련 기능은 아직 알파 단계이기 때문에 오늘은 해당 기능에 대한 자세한 설명보다는 운영체제 관련 기반 지식을 먼저 소개하도록 하겠다.

지금은 아니지만, 예전에는 리눅스 커널을 공부하려는 사람들이 많았었고, 이들이 가장 힘겨워하는 부분이 바로 메모리 관리였다. 그리고 이 메모리 관리에서 가장 핵심적인 부분이 페이징인데, 사실 개념은 간단하지만 리눅스 커널 코드 레벨에서 해당 기능을 정확히 이해하기 위해서는 x86 보호모드 및 MMU 기능부터 상당히 복잡한 많은 지식이 필요하다. 운영체제를 공부하다보면 늘 듣는 **사용자 프로세스는 커널 주소 공간에 접근할 수 없다**, **메모리를 미리 읽지 않고 사용 시점에 읽어들인다** 등등이 모두 보호모드와 페이징에 기반하여 구현된다. 하지만 리눅스 커널 개발에 참여할 계획이 없다면 이렇게 자세한 내용까지 알 필요는 없으니 간단히 개념적인 부분에 대해서만 이해하고 다음 단계로 넘어가보도록 하자.

페이징은 간단히 얘기하면 메모리를 일정한 크기의 페이지(보통 4KB)로 나누어 관리하자는 것이다. 왜 이렇게 해야하지라는 생각이 들면, 페이징없이 수많은 프로세스가 다양한 크기의 메모리를 할당하고 해제하는 과정을 한번 상상해보자. 조만간 메모리는 엄청난 단편화가 발생하여 실제 가용한 메모리가 많더라도 연속적인 메모리를 할당하기 힘든 지경에 이를 것이다. 그렇다면 이러한 문제를 페이징은 어떻게 해결하고 있을까? 바로 아래의 두 가지가 핵심 포인트이다.

1. 물리 메모리에 직접 접근하지 않고 가상 메모리 주소를 통해 물리 메모리에 접근한다. (물리적으로 연속적이지 않더라도 가상적으로는 연속적으로 보이게 만들겠다는 것이다.)
2. 가상 메모리와 물리 메모리를 동일한 크기의 페이지로 나누어 관리한다. (페이지 단위로 할당/해제를 반복함으로써 단편화 문제를 해결하겠다는 것이다.)

**언제나 연속적인 메모리 공간을 확보하는 것이 메모리 관리의 핵심이고, 페이징은 이를 위해 동일한 크기의 페이지를 사용하여 단편화 문제를 해결하였고, 물리 메모리 주소로 바로 접근하는 것이 아닌 가상 메모리 주소를 사용함으로써 연속성 문제를 해결하였다.**
